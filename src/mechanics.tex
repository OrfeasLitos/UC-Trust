\section{Mechanics}
  More precisely, let $\mathcal{D}$ be a (finite) set containing all possible desires. At arbitrary moments during execution,
  $\mathcal{E}$ can provide input to any player $Alice \in \mathcal{P}$ in the form $\left(idx, d\right)$, where $idx \in
  \mathbb{N}, d \in \mathcal{D}, u \in \mathbb{R}^{+}$. $idx$ represents an index number that is unique for each input
  generated by $\mathcal{E}$ and $d$ represents the desire. $d$ is satisfied when $Alice$ learns the string $s\left(idx, d,
  Alice\right)$, either by directly calculating it or by receiving it as subroutine output from another player. Some of the
  players, given as input the tuple $\left(idx, d, Alice\right)$, can calculate $s\left(idx, d, Alice\right)$ more efficiently
  than $Alice$, which means that they need to consume less input tokens than $Alice$ for this calculation. $Alice$ can choose
  to delegate this calculation to a more efficient player $Bob$ and provide the necessary input tokens for his computation with
  a surplus to compensate $Bob$ for his effort. Both players are better off, because $Alice$ spent less tokens than she would
  if she had calculated $s\left(idx, d, Alice\right)$ herself, whilst $Bob$ obtained some tokens which can in turn be used to
  satisfy some of his future desires.
 
  \subimport{./definitions/}{costofdesire.tex}

  It is reasonable to assume that there exists an absolute minimum of tokens that must be spent for the satisfaction of a
  desire, no matter how efficient the calculating party is.

  \subimport{./definitions/}{minimumcostofdesire.tex}

  \noindent Note that $1 \leq c_{min}\left(idx, d, Alice\right) \leq \min\limits_{v \in \mathcal{P}}{c\left(idx, d, Alice,
  v\right)}$.

  \subimport{./definitions/}{playerofdesire.tex}

  \subimport{./definitions/}{issatisfied.tex}

  \subimport{./definitions/}{desiresofplayer.tex}
  It is straightforward to see that
  \begin{equation*}
    \forall v \in \mathcal{P}, SatDesires\left(v\right) \cap UnsatDesires\left(v\right) = \emptyset \enspace.
  \end{equation*}
  If additionally we suppose that $isSatisfied\left(\right)$ is always a computable function, then
  \begin{equation*}
    \forall v \in \mathcal{P}, Desires\left(v\right) = SatDesires\left(v\right) \cup UnsatDesires\left(v\right) \enspace.
  \end{equation*}
  $\mathcal{E}$ can calculate the functions and the property defined above for all inputs at any moment in time.

  The game begins with all players being created by $\mathcal{E}$, each allocated a random amount (TODO: define distribution)
  of input tokens. The game ends at a moment specified by the $\mathcal{E}$, which is unknown to the players. At that moment
  $\mathcal{E}$ assigns a utility to each player depending on which desires were satisfied throughout the game.

  \subimport{./definitions/}{utility.tex}
