\section{Mechanics}
  More precisely, let $\mathcal{D}$ be a set containing all possible desires. At arbitrary
  moments during execution, $\mathcal{E}$ can provide input to any player $Alice \in
  \mathcal{P}$ in the form $\left(idx, d\right)$, where $idx \in \mathbb{N}, d \in
  \mathcal{D}, u \in \mathbb{R}^{+}$. $idx$ represents an index number that is unique for
  each input generated by $\mathcal{E}$ and $d$ represents the desire. $d$ is satisfied
  when $Alice$ learns the string $s\left(idx, d, Alice\right)$, either by directly
  calculating it or by receiving it as a message from another player. Some of the players,
  given as input the tuple $\left(idx, d, Alice\right)$, can calculate $s\left(idx, d,
  Alice\right)$ more efficiently than $Alice$, which means that they need to consume less
  input tokens than $Alice$ for this calculation. $Alice$ can choose to delegate this
  calculation to a more efficient player $Bob$ and provide the necessary input tokens for
  his computation with a surplus to compensate $Bob$ for his effort. Both players are
  better off, because $Alice$ spent less tokens than she would if she had calculated
  $s\left(idx, d, Alice\right)$ herself, whilst $Bob$ obtained some tokens which can in
  turn be used to satisfy some of his future desires.

  Since $Bob$ can commit fraud and get the tokens without satisfying $Alice$'s desire in
  exchange, $Alice$ must be well informed on the trustworthiness of potential
  collaborators before handing in the tokens. $Alice$ can use any out-of-band means to
  this end, which we model as an oracle $\mathcal{O}_{\mathrm{Trust}}$ which is input a
  desire and a list of potential players and returns the player that increases the utility
  the most (on expectation), along with the expected utility increase.

  \subimport{./definitions/}{costofdesire.tex}

  It is reasonable to assume that there exists an absolute minimum of tokens that must be
  spent for the satisfaction of a desire, no matter how efficient the calculating party
  is.

  \subimport{./definitions/}{minimumcostofdesire.tex}

  \noindent Note that $1 \leq c_{min}\left(idx, d, Alice\right) \leq \min\limits_{v \in
  \mathcal{P}}{c\left(idx, d, Alice, v\right)}$.

  \subimport{./definitions/}{playerofdesire.tex}

  \subimport{./definitions/}{issatisfied.tex}

  \subimport{./definitions/}{desiresofplayer.tex}
  It is straightforward to see that
  \begin{equation*}
    \forall v \in \mathcal{P}, SatDesires\left(v\right) \cap UnsatDesires\left(v\right) =
    \emptyset \enspace.
  \end{equation*}
  If additionally we suppose that $isSatisfied\left(\right)$ is always a computable
  function, then
  \begin{equation*}
    \forall v \in \mathcal{P}, Desires\left(v\right) = SatDesires\left(v\right) \cup
    UnsatDesires\left(v\right) \enspace.
  \end{equation*}
  $\mathcal{E}$ can calculate the functions and the property defined above for all inputs
  at any moment in time.

  The game begins with all players being created by $\mathcal{E}$, each allocated a number
  of tokens determined by the $\mathcal{F}_{\mathrm{Ledger}}$ functionality (more on that
  later).  The game ends at a moment specified by the $\mathcal{E}$, which is unknown to
  the players. At that moment $\mathcal{E}$ assigns a utility to each player depending on
  which desires were satisfied throughout the game.

  \subimport{./definitions/}{utility.tex}
