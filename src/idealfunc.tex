\section{Desire Satisfaction Ideal Functionality}
  Following the UC paradigm, in this section we define the ideal functionality for desire
  satisfaction, $\mathcal{F}_{\mathrm{SAT}}$. In this setting, all the desires that are
  generated by the environment and are input to the players are immediately forwarded to
  $\mathcal{F}_{\mathrm{SAT}}$; the functionality decides which desires to satisfy. Since
  the players are dummy and all desires are satisfied by the functionality, no trust
  semantics amongst the players are necessary.

  Nevertheless, given that all desires have a minimum cost, the cost semantics are still
  necessary, as we show with the following example: Consider a set of desires $D$ with
  more elements than the total number of tokens all players have. $D$ could never be
  satisfied by the players because of the high total cost, but a
  $\mathcal{F}_{\mathrm{SAT}}$ with no consideration for cost could in principle satisfy
  all desires in $D$.

  The functionality can calculate the properties and functions defined
  in~\ref{playerofdesire},~\ref{issatisfied} and~\ref{desiresofplayer}\ for all inputs at
  any moment in time.

  Without knowledge of the utilities the environment is going to give to each satisfied
  desire, the functionality may fail spectacularly. So knowledge of the utility of each
  desire, or at least some function of the utility given the desires is needed. We can
  assume that $\mathcal{F}_{\mathrm{SAT}}$ knows $U$ or an approximation of it.

  Going into more detail, $\mathcal{F}_{\mathrm{SAT}}$ is a stateful process that acts as
  a market and as a bank for the players. The market does not offer a particular product
  for the same price to all users; For some users it may be cheaper than for others,
  reflecting the fact that some players can realize some desires more efficiently than
  others.

  $\mathcal{F}_{\mathrm{SAT}}$ stores a number for each player that represents the amount
  of tokens this player has and a table with the price of each desire for each player. It
  provides the functions $cost\left(u, d\right)$ which returns the cost of the desire $d$
  for player $u$ with no side effects, $sat\left(u, d\right)$ that returns the string that
  satisfies the desire $d$ to $u$ and reduces the amount of the tokens belonging to $u$ by
  $cost\left(u, d\right)$. There exists also the function $transfer\left(u_1, u_2,
  t\right)$ which reduces the amount of tokens $u_1$ has by $t$ and increases the tokens
  of $u_2$ by $t$, given that initially the tokens belonging to $u_1$ were equal or more
  than $t$. This function is private to the functionality, thus can be used only
  internally.

  \subimport{algorithms/}{satfunc.tex}
  \subimport{./}{rpdpayoffs.tex}
  \subimport{algorithms/}{tradefunc.tex}
  \subimport{algorithms/}{assetsfunc.tex}
  \subimport{algorithms/}{tradeprot.tex}
