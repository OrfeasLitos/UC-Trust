\Suppressnumber
\begin{lstlisting}[label=satfunc, style=numbers]
(*@$\mathcal{F}_{SAT}$ \Reactivatenumber@*)
Initialisation:
  (*@$\forall Alice \in \mathcal{P},$@*)
    util((*@$Alice$@*)) = (*@$\bot$@*)
    assets((*@$Alice$@*)) = (*@$\bot$@*)

Upon receiving type((*@$t$@*)) from (*@$Alice$@*):
  util((*@$Alice$@*)) = (*@$t$@*)

Upon receiving satisfy((*@$d, L$@*)) from (*@$Alice$@*):
  If util((*@$Alice$@*)) == (*@$\bot$@*):
    send message utilityNotSet() to (*@$Alice$@*)
    go to Idle state
  Find sat = (*@$\left(Bob, x, s\right) \in L \times \mathbb{R} \times Assets$@*):
    (*@$s \in$@*) assets((*@$Bob$@*)) and (*@$s \in d$@*) and (*@$x \geq 0$@*) and
    (*@$Alice$@*) has at least (*@$x$@*) coins available and
    util((*@$Alice$@*))(after trade) > util((*@$Alice$@*))(before trade)
    and
    util((*@$Bob$@*))(after trade) > util((*@$Bob$@*))(before trade)
    and
    util((*@$Bob$@*))(after trade) > util((*@$Bob$@*))(after cheating)
    and
    util((*@$Alice$@*))(after trade) maximum amongst possible choices
  With sat as (*@$\left(Bob, x, s\right)$@*):
    If (*@$x > 0$@*):
      Pay (*@$x$@*) from (*@$Alice$@*) to (*@$Bob$@*)
    assets((*@$Bob$@*)) = assets((*@$Bob$@*))(*@$\setminus \left\{s\right\}$@*)
    assets((*@$Alice$@*)) = assets((*@$Alice$@*))(*@$\cup \left\{s\right\}$@*)
    send message satisfied((*@$d, L$@*)) to (*@$Alice$@*)
  Else If sat == (*@$\bot$@*)
    send message unsatisfied((*@$d, L$@*)) to (*@$Alice$@*)

Upon receiving obtain((*@$s$@*)) from (*@$Alice$@*):
  assets((*@$Alice$@*)) = assets((*@$Alice$@*))(*@$\cup \left\{s\right\}$@*)
  send message obtained((*@$s$@*)) to (*@$Alice$@*)

Upon receiving lose((*@$s$@*)) from (*@$Alice$@*):
  assets((*@$Alice$@*)) = assets((*@$Alice$@*))(*@$\setminus \left\{s\right\}$@*)
  send message lost((*@$s$@*)) to (*@$Alice$@*)
\end{lstlisting}
